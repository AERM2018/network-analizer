from concurrent.futures import ThreadPoolExecutor
import csv
import os
import threading
import requests
from helpers import http
import socket
import struct
import numpy as np
import pandas as pd
from dotenv import load_dotenv
import scapy.all as scapy
from tasks.pandas_analizer import Pandas_analizer
from tasks.network_commads import Command_executer
from tasks.pandas_analizer import Pandas_analizer
import mechanize
import colorama
class Vulnerability_executor():
    def __init__(self,target_ip):
        self.target_ip = target_ip
        load_dotenv()
        colorama.init()

    def exec_ddos_attack(self):
        for i in range(10):
            t = threading.Thread(target=http.do_call,args=['http://{}:80'.format(self.target_ip),'GET'])
            t.start()
            print('Request n. {} sent'.format(i))

    def exec_sniffer(self):
        print(colorama.Fore.RESET,end='')
        # the public network interface
        HOST = socket.gethostbyname(socket.gethostname())
        # create a raw socket and bind it to the public interface
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)
        s.bind((HOST,0))
        # Include IP headers
        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
        # receive all packages
        s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        # receive a package
        # Open csv file to save the log on it
        sniffer_log = open('./logs/traffic.csv','w',newline='')
        log_writter = csv.writer(sniffer_log,delimiter=',')
        log_writter.writerow(['target_ip','source_ip','total_length'])
        n=1
        while(n<=500):
            packet, address =s.recvfrom(65565) 
            header = struct.unpack('! B B H H H B B H 4s 4s' , packet[:20])
            if('.'.join(map(str, header[9])) != HOST):
                log_writter.writerow(['.'.join(map(str, header[9])),'.'.join(map(str, header[8])),header[2]])
            n=n+1
        sniffer_log.close()
        # Analize the info and make a plot of it
        pd_analizer = Pandas_analizer()
        statistics = pd_analizer.analize_data(pd.read_csv('./logs/traffic.csv'),['target_ip'],'total_length',4)
        # Write in a txt the name resolution of the target ips
        net_exec = Command_executer(statistics['target_ip'].to_list())
        net_exec.nslookup()
        print(colorama.Fore.LIGHTYELLOW_EX+'--> Check names resolution in the file nslookup.txt in logs folder <--')
        print(colorama.Fore.RESET,end='')
        pd_analizer.plot_data(statistics,'target_ip','total_length','Outcoming traffic','N. bytes','Ip')

    def exec_wifi_scanner(self):
        target_ip = os.getenv('WIFI_SCAN_IP')
        arp = scapy.ARP(pdst=target_ip)
        # create the Ether broadcast packet
        ether = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        # stack them
        packet = ether/arp
        result = scapy.srp(packet, timeout=3, verbose=0)[0]
        clients = []
        for sent, received in result:
            # for each response, append ip and mac address to `clients` list
            clients.append({'ip': received.psrc, 'mac': received.hwsrc})
        # save it on a log file
        wifi_scan_log = open('./logs/wifi_scan_log.txt','w')
        wifi_scan_log.write("Available devices in the network:\n")
        wifi_scan_log.write("IP" + " "*18+"MAC\n")
        for client in clients:
            wifi_scan_log.write("{:16}    {}\n".format(client['ip'], client['mac']))
        print(colorama.Fore.LIGHTYELLOW_EX+'--> Check scanner results in the file wifi_scan_log.txt in logs folder <--')

    def exec_sqli(self):
        url = 'http://testphp.vulnweb.com/artists.php?artist=2 order by 20'
        s = requests.Session()
        res = s.get(url)
        errors = {
        # MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        # SQL Server
        "unclosed quotation mark after the character string",
        # Oracle
        "quoted string not properly terminated",
        }
        for error in errors:
            if error in res.content.decode().lower():
                print(colorama.Fore.LIGHTRED_EX+'The webpage {} presents a SQL Injection vulnerability'.format(url))
                return
        print(colorama.Fore.WHITE+'The webpage {} doesn\'t presents a SQL Injection vulnerability'.format(url))
    
    def exec_port_scanner(self):
        print(colorama.Fore.RESET,end='')
        num_threads = 3
        threads_list = []
        th_exec = ThreadPoolExecutor(num_threads)
        # Run threads and append them to the list
        for i in range(num_threads):
            threads_list.append(th_exec.submit(self.__return_open_ports,100*i,100*(i+1)))
        # Get the threads result and create a plot of it
        log_file = open('./logs/port_scanner_log.csv','w')
        log_writter = csv.writer(log_file,delimiter=',')
        log_writter.writerow(['port range','ports open'])
        for i in range(len(threads_list)):
            log_writter.writerow(['{}-{}'.format(100*i,100*(i+1)),len(threads_list[i].result())])
        log_file.close()
        pn_analyzer = Pandas_analizer()
        pn_analyzer.plot_data(pd.read_csv('./logs/port_scanner_log.csv'),'port range','ports open','Port analizer','N. open ports','Port range')

    def __return_open_ports(self,from_port, to_port,):
        open_ports = []
        for port in range(from_port, to_port):
            sock = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
            sock.settimeout(.10)
            if sock.connect_ex((self.target_ip,port)) == 0:
                open_ports.append(port)
        sock.close()
        return open_ports