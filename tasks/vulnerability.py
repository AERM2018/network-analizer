import csv
import os
import threading
import requests
from matplotlib.pyplot import sca
from helpers import http
import socket
import struct
import numpy as np
import pandas as pd
from dotenv import load_dotenv
import scapy.all as scapy
from tasks.pandas_analizer import Pandas_analizer
from tasks.network_commads import Command_executer
import mechanize
class Vulnerability_executor():
    def __init__(self,target_ip):
        self.target_ip = target_ip
        load_dotenv()

    def exec_ddos_attack(self):
        for i in range(10):
            t = threading.Thread(target=http.do_call,args=['http://{}:80'.format(self.target_ip),'GET'])
            t.start()
            print('Request n. {} sent'.format(i))

    def exec_sniffer(self):
        # the public network interface
        HOST = socket.gethostbyname(socket.gethostname())
        # create a raw socket and bind it to the public interface
        s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_IP)
        s.bind((HOST,0))
        # Include IP headers
        s.setsockopt(socket.IPPROTO_IP, socket.IP_HDRINCL, 1)
        # receive all packages
        s.ioctl(socket.SIO_RCVALL, socket.RCVALL_ON)
        # receive a package
        # Open csv file to save the log on it
        sniffer_log = open('./logs/traffic.csv','w',newline='')
        log_writter = csv.writer(sniffer_log,delimiter=',')
        log_writter.writerow(['target_ip','source_ip','total_length'])
        n=1
        while(n<=500):
            print('Packet n. {} analyzed'.format(n))
            packet, address =s.recvfrom(65565) 
            header = struct.unpack('! B B H H H B B H 4s 4s' , packet[:20])
            if('.'.join(map(str, header[9])) != HOST):
                log_writter.writerow(['.'.join(map(str, header[9])),'.'.join(map(str, header[8])),header[2]])
            n=n+1
        sniffer_log.close()
        # Analize the info and make a plot of it
        pd_analizer = Pandas_analizer()
        statistics = pd_analizer.analize_data(pd.read_csv('./logs/traffic.csv'),['target_ip'],'total_length',4)
        # Write in a txt the name resolution of the target ips
        net_exec = Command_executer(statistics['target_ip'].to_list())
        net_exec.nslookup()
        pd_analizer.plot_data(statistics,'target_ip','total_length','Outcoming traffic','N. bytes','Ip')

    def exec_wifi_scanner(self):
        target_ip = os.getenv('WIFI_SCAN_IP')
        arp = scapy.ARP(pdst=target_ip)
        # create the Ether broadcast packet
        ether = scapy.Ether(dst="ff:ff:ff:ff:ff:ff")
        # stack them
        packet = ether/arp
        result = scapy.srp(packet, timeout=3, verbose=0)[0]
        clients = []
        for sent, received in result:
            # for each response, append ip and mac address to `clients` list
            clients.append({'ip': received.psrc, 'mac': received.hwsrc})
        # save it on a log file
        wifi_scan_log = open('./logs/wifi_scan_log.txt','w')
        wifi_scan_log.write("Available devices in the network:\n")
        wifi_scan_log.write("IP" + " "*18+"MAC\n")
        for client in clients:
            wifi_scan_log.write("{:16}    {}\n".format(client['ip'], client['mac']))


    def exec_sqli(self):
        url = 'http://testphp.vulnweb.com/artists.php?artist=2 order by 20'
        s = requests.Session()
        res = s.get(url)
        errors = {
        # MySQL
        "you have an error in your sql syntax;",
        "warning: mysql",
        # SQL Server
        "unclosed quotation mark after the character string",
        # Oracle
        "quoted string not properly terminated",
        }
        for error in errors:
            if error in res.content.decode().lower():
                print('theres a vuln')
                return
        print('theres no a vuln')